{
  "name": "stack",
  "description": "Stack is a minimal http module system for node.js",
  "tags": [
    "connect",
    "middleware",
    "stack",
    "http"
  ],
  "version": "0.1.0",
  "author": {
    "name": "Tim Caswell",
    "email": "tim@creationix.com"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/creationix/stack.git"
  },
  "bugs": {
    "url": "http://github.com/creationix/stack/issues"
  },
  "engines": [
    "node >= 0.2.0"
  ],
  "main": "stack.js",
  "readme": "# Stack\n\nStack is a minimal http module system for node.js.\n\nBasically it's the core idea of connect but in a standalone and super minimal stack function.\n\n## Install\n\nIf you use npm, then install stack via npm.  Also, remember to put it as a dependency in your own project's package.json file.\n\n    npm install stack\n\nIf you don't use npm (Like you're on a phone), then simply copy the single file `stack.js` somewhere you can get to it.\n\n## Example\n\n    http.createServer(require('stack')(\n      require('loggerMiddleware')(),\n      require('staticMiddleware')(root, mount),\n      //...\n    )).listen(8080);\n\n## Explanation\n\nAs you can see, it takes a list of handler functions and will chain them up for you.\n\nEach handler needs to be of the form:\n\n    function handler(req, res, next) {\n      // Either handle the request here using `req` and `res`\n      // or call `next()` to pass control to next layer\n      // any exceptions need to be caught and forwarded to `next(err)`\n    }\n\nWhen using external modules a good convention is to make the module be a callable setup function that returns the handler function.  The first example uses modules created after this pattern.\n\n    module.exports = function setup(some, args) {\n      // Do server set up stuff here\n      return function handle(req, res, next) {\n        // Handle a single request here\n      };\n    };\n\n## What Stack Does\n\nBesides providing this nice linear syntax for defining http handler layers Stack does a few things under the hood.\n\n - Wraps each layer in a `try..catch` to catch any exceptions that happen in the main execution stack layer's handler function.\n - Provides a fallthrough error handler function that returns 404 for routes that fall through all the layers and 500 responses for exceptions.\n   (You can override this at Stack.errorHandler, if for example, you don't like showing stack traces for all errors or want to pretty it up a bit)\n - Forwards and exceptions passed to any next layer directly to the error handler.  This means layers don't have to worry about errors from previous layers.\n\n## What Stack Does NOT Do\n\nStack does not provide any middleware layers of any kind.  If you want logging, or static file serving or anything, you have to provide your own handlers.\nThe reason is two-fold.  First, it keeps Stack nice and small and easy to maintain.  This worked great for my Step library and I think it will work great for Stack.\nSecond, I found with Connect, that having a central place where all middleware is kept is not good for the community.  People want different things from eachother, and it's impossible to accept patches and feature requests that make everyone happy.  Better I think is to provide a nice system for layering third-party modules and let each module succeed on it's own merit.\n\n",
  "readmeFilename": "README.markdown",
  "homepage": "https://github.com/creationix/stack",
  "_id": "stack@0.1.0",
  "_from": "stack@~0.1.0"
}
